// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "gen-cpp/WebService.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>
#include "Manager.h"

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using boost::shared_ptr;

using namespace ::ws;

class WebServiceHandler: virtual public WebServiceIf {
private:
	Manager _mgr;
public:
	WebServiceHandler() :
			_mgr("/opt/duesseldorf-regbez-latest.osm.pbf") {
		// Your initialization goes here
	}

	int64_t findNode(const std::string& street, const std::string& postal) {
		try {
			auto id = _mgr.findNodeByStreet(street, postal);

			return id;
		} catch (ManagerError &ex) {
			WebServiceException wex;
			wex.__set_what(ex.what());

			throw wex;
		}
	}

	void calcShortestWay(std::vector<Coordinate> & _return,
			const std::string& algorithm, const int64_t startNode,
			const int64_t endNode) {
		try {
			if (algorithm == "dijkstra") {
				Algorithm::WayTracker tracker;
				bool succ = _mgr.runAlgorithm(Manager::Dijkstra, startNode,
						endNode, tracker);

				if (succ == false) {
					WebServiceException wex;
					wex.__set_what("Weg nicht gefunden");
					throw wex;
				} else {
					tracker.calcWay();
					tracker.traverse([&_return](Graph::Node_sp &node)
					{
						ws::Coordinate coord;
						coord.lat = node->lat();
						coord.lon = node->lon();
						_return.push_back(coord);
					});
				}
			}
			else if (algorithm == "astar") {
				Algorithm::WayTracker tracker;
				bool succ = _mgr.runAlgorithm(Manager::AStar, startNode,
						endNode, tracker);

				if (succ == false) {
					WebServiceException wex;
					wex.__set_what("Weg nicht gefunden");
					throw wex;
				} else {
					tracker.calcWay();
					tracker.traverse([&_return](Graph::Node_sp &node)
					{
						ws::Coordinate coord;
						coord.lat = node->lat();
						coord.lon = node->lon();
						_return.push_back(coord);
					});
				}
			}
			else
			{
				WebServiceException wex;
				wex.__set_what("Der Algorithmus wird nicht unterstuetzt");
				throw wex;
			}
		} catch (ManagerError &ex) {
			WebServiceException wex;
			wex.__set_what(ex.what());

			throw wex;
		}
	}

};

int main(int argc, char **argv) {
	int port = 9090;
	std::cout << "Initializing Web Service" << std::endl;
	shared_ptr<WebServiceHandler> handler(new WebServiceHandler());
	shared_ptr<TProcessor> processor(new WebServiceProcessor(handler));
	shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
	shared_ptr<TTransportFactory> transportFactory(
			new TBufferedTransportFactory());
	shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

	std::cout << "Starting Thrift" << std::endl;
	TSimpleServer server(processor, serverTransport, transportFactory,
			protocolFactory);
	server.serve();
	return 0;
}

